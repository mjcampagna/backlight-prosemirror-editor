{
  "version": 3,
  "sources": ["../../prosemirror-markdown/dist/index.js"],
  "sourcesContent": ["import { Schema, Mark } from 'prosemirror-model';\nimport MarkdownIt from 'markdown-it';\n\n/**\nDocument schema for the data model used by CommonMark.\n*/\nconst schema = new Schema({\n    nodes: {\n        doc: {\n            content: \"block+\"\n        },\n        paragraph: {\n            content: \"inline*\",\n            group: \"block\",\n            parseDOM: [{ tag: \"p\" }],\n            toDOM() { return [\"p\", 0]; }\n        },\n        blockquote: {\n            content: \"block+\",\n            group: \"block\",\n            parseDOM: [{ tag: \"blockquote\" }],\n            toDOM() { return [\"blockquote\", 0]; }\n        },\n        horizontal_rule: {\n            group: \"block\",\n            parseDOM: [{ tag: \"hr\" }],\n            toDOM() { return [\"div\", [\"hr\"]]; }\n        },\n        heading: {\n            attrs: { level: { default: 1 } },\n            content: \"(text | image)*\",\n            group: \"block\",\n            defining: true,\n            parseDOM: [{ tag: \"h1\", attrs: { level: 1 } },\n                { tag: \"h2\", attrs: { level: 2 } },\n                { tag: \"h3\", attrs: { level: 3 } },\n                { tag: \"h4\", attrs: { level: 4 } },\n                { tag: \"h5\", attrs: { level: 5 } },\n                { tag: \"h6\", attrs: { level: 6 } }],\n            toDOM(node) { return [\"h\" + node.attrs.level, 0]; }\n        },\n        code_block: {\n            content: \"text*\",\n            group: \"block\",\n            code: true,\n            defining: true,\n            marks: \"\",\n            attrs: { params: { default: \"\" } },\n            parseDOM: [{ tag: \"pre\", preserveWhitespace: \"full\", getAttrs: node => ({ params: node.getAttribute(\"data-params\") || \"\" }) }],\n            toDOM(node) { return [\"pre\", node.attrs.params ? { \"data-params\": node.attrs.params } : {}, [\"code\", 0]]; }\n        },\n        ordered_list: {\n            content: \"list_item+\",\n            group: \"block\",\n            attrs: { order: { default: 1 }, tight: { default: false } },\n            parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                        return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1,\n                            tight: dom.hasAttribute(\"data-tight\") };\n                    } }],\n            toDOM(node) {\n                return [\"ol\", { start: node.attrs.order == 1 ? null : node.attrs.order,\n                        \"data-tight\": node.attrs.tight ? \"true\" : null }, 0];\n            }\n        },\n        bullet_list: {\n            content: \"list_item+\",\n            group: \"block\",\n            attrs: { tight: { default: false } },\n            parseDOM: [{ tag: \"ul\", getAttrs: dom => ({ tight: dom.hasAttribute(\"data-tight\") }) }],\n            toDOM(node) { return [\"ul\", { \"data-tight\": node.attrs.tight ? \"true\" : null }, 0]; }\n        },\n        list_item: {\n            content: \"block+\",\n            defining: true,\n            parseDOM: [{ tag: \"li\" }],\n            toDOM() { return [\"li\", 0]; }\n        },\n        text: {\n            group: \"inline\"\n        },\n        image: {\n            inline: true,\n            attrs: {\n                src: {},\n                alt: { default: null },\n                title: { default: null }\n            },\n            group: \"inline\",\n            draggable: true,\n            parseDOM: [{ tag: \"img[src]\", getAttrs(dom) {\n                        return {\n                            src: dom.getAttribute(\"src\"),\n                            title: dom.getAttribute(\"title\"),\n                            alt: dom.getAttribute(\"alt\")\n                        };\n                    } }],\n            toDOM(node) { return [\"img\", node.attrs]; }\n        },\n        hard_break: {\n            inline: true,\n            group: \"inline\",\n            selectable: false,\n            parseDOM: [{ tag: \"br\" }],\n            toDOM() { return [\"br\"]; }\n        }\n    },\n    marks: {\n        em: {\n            parseDOM: [\n                { tag: \"i\" }, { tag: \"em\" },\n                { style: \"font-style=italic\" },\n                { style: \"font-style=normal\", clearMark: m => m.type.name == \"em\" }\n            ],\n            toDOM() { return [\"em\"]; }\n        },\n        strong: {\n            parseDOM: [\n                { tag: \"strong\" },\n                { tag: \"b\", getAttrs: node => node.style.fontWeight != \"normal\" && null },\n                { style: \"font-weight=400\", clearMark: m => m.type.name == \"strong\" },\n                { style: \"font-weight\", getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null }\n            ],\n            toDOM() { return [\"strong\"]; }\n        },\n        link: {\n            attrs: {\n                href: {},\n                title: { default: null }\n            },\n            inclusive: false,\n            parseDOM: [{ tag: \"a[href]\", getAttrs(dom) {\n                        return { href: dom.getAttribute(\"href\"), title: dom.getAttribute(\"title\") };\n                    } }],\n            toDOM(node) { return [\"a\", node.attrs]; }\n        },\n        code: {\n            code: true,\n            parseDOM: [{ tag: \"code\" }],\n            toDOM() { return [\"code\"]; }\n        }\n    }\n});\n\n// @ts-ignore\nfunction maybeMerge(a, b) {\n    if (a.isText && b.isText && Mark.sameSet(a.marks, b.marks))\n        return a.withText(a.text + b.text);\n}\n// Object used to track the context of a running parse.\nclass MarkdownParseState {\n    constructor(schema, tokenHandlers) {\n        this.schema = schema;\n        this.tokenHandlers = tokenHandlers;\n        this.stack = [{ type: schema.topNodeType, attrs: null, content: [], marks: Mark.none }];\n    }\n    top() {\n        return this.stack[this.stack.length - 1];\n    }\n    push(elt) {\n        if (this.stack.length)\n            this.top().content.push(elt);\n    }\n    // Adds the given text to the current position in the document,\n    // using the current marks as styling.\n    addText(text) {\n        if (!text)\n            return;\n        let top = this.top(), nodes = top.content, last = nodes[nodes.length - 1];\n        let node = this.schema.text(text, top.marks), merged;\n        if (last && (merged = maybeMerge(last, node)))\n            nodes[nodes.length - 1] = merged;\n        else\n            nodes.push(node);\n    }\n    // Adds the given mark to the set of active marks.\n    openMark(mark) {\n        let top = this.top();\n        top.marks = mark.addToSet(top.marks);\n    }\n    // Removes the given mark from the set of active marks.\n    closeMark(mark) {\n        let top = this.top();\n        top.marks = mark.removeFromSet(top.marks);\n    }\n    parseTokens(toks) {\n        for (let i = 0; i < toks.length; i++) {\n            let tok = toks[i];\n            let handler = this.tokenHandlers[tok.type];\n            if (!handler)\n                throw new Error(\"Token type `\" + tok.type + \"` not supported by Markdown parser\");\n            handler(this, tok, toks, i);\n        }\n    }\n    // Add a node at the current position.\n    addNode(type, attrs, content) {\n        let top = this.top();\n        let node = type.createAndFill(attrs, content, top ? top.marks : []);\n        if (!node)\n            return null;\n        this.push(node);\n        return node;\n    }\n    // Wrap subsequent content in a node of the given type.\n    openNode(type, attrs) {\n        this.stack.push({ type: type, attrs: attrs, content: [], marks: Mark.none });\n    }\n    // Close and return the node that is currently on top of the stack.\n    closeNode() {\n        let info = this.stack.pop();\n        return this.addNode(info.type, info.attrs, info.content);\n    }\n}\nfunction attrs(spec, token, tokens, i) {\n    if (spec.getAttrs)\n        return spec.getAttrs(token, tokens, i);\n    // For backwards compatibility when `attrs` is a Function\n    else if (spec.attrs instanceof Function)\n        return spec.attrs(token);\n    else\n        return spec.attrs;\n}\n// Code content is represented as a single token with a `content`\n// property in Markdown-it.\nfunction noCloseToken(spec, type) {\n    return spec.noCloseToken || type == \"code_inline\" || type == \"code_block\" || type == \"fence\";\n}\nfunction withoutTrailingNewline(str) {\n    return str[str.length - 1] == \"\\n\" ? str.slice(0, str.length - 1) : str;\n}\nfunction noOp() { }\nfunction tokenHandlers(schema, tokens) {\n    let handlers = Object.create(null);\n    for (let type in tokens) {\n        let spec = tokens[type];\n        if (spec.block) {\n            let nodeType = schema.nodeType(spec.block);\n            if (noCloseToken(spec, type)) {\n                handlers[type] = (state, tok, tokens, i) => {\n                    state.openNode(nodeType, attrs(spec, tok, tokens, i));\n                    state.addText(withoutTrailingNewline(tok.content));\n                    state.closeNode();\n                };\n            }\n            else {\n                handlers[type + \"_open\"] = (state, tok, tokens, i) => state.openNode(nodeType, attrs(spec, tok, tokens, i));\n                handlers[type + \"_close\"] = state => state.closeNode();\n            }\n        }\n        else if (spec.node) {\n            let nodeType = schema.nodeType(spec.node);\n            handlers[type] = (state, tok, tokens, i) => state.addNode(nodeType, attrs(spec, tok, tokens, i));\n        }\n        else if (spec.mark) {\n            let markType = schema.marks[spec.mark];\n            if (noCloseToken(spec, type)) {\n                handlers[type] = (state, tok, tokens, i) => {\n                    state.openMark(markType.create(attrs(spec, tok, tokens, i)));\n                    state.addText(withoutTrailingNewline(tok.content));\n                    state.closeMark(markType);\n                };\n            }\n            else {\n                handlers[type + \"_open\"] = (state, tok, tokens, i) => state.openMark(markType.create(attrs(spec, tok, tokens, i)));\n                handlers[type + \"_close\"] = state => state.closeMark(markType);\n            }\n        }\n        else if (spec.ignore) {\n            if (noCloseToken(spec, type)) {\n                handlers[type] = noOp;\n            }\n            else {\n                handlers[type + \"_open\"] = noOp;\n                handlers[type + \"_close\"] = noOp;\n            }\n        }\n        else {\n            throw new RangeError(\"Unrecognized parsing spec \" + JSON.stringify(spec));\n        }\n    }\n    handlers.text = (state, tok) => state.addText(tok.content);\n    handlers.inline = (state, tok) => state.parseTokens(tok.children);\n    handlers.softbreak = handlers.softbreak || (state => state.addText(\" \"));\n    return handlers;\n}\n/**\nA configuration of a Markdown parser. Such a parser uses\n[markdown-it](https://github.com/markdown-it/markdown-it) to\ntokenize a file, and then runs the custom rules it is given over\nthe tokens to create a ProseMirror document tree.\n*/\nclass MarkdownParser {\n    /**\n    Create a parser with the given configuration. You can configure\n    the markdown-it parser to parse the dialect you want, and provide\n    a description of the ProseMirror entities those tokens map to in\n    the `tokens` object, which maps token names to descriptions of\n    what to do with them. Such a description is an object, and may\n    have the following properties:\n    */\n    constructor(\n    /**\n    The parser's document schema.\n    */\n    schema, \n    /**\n    This parser's markdown-it tokenizer.\n    */\n    tokenizer, \n    /**\n    The value of the `tokens` object used to construct this\n    parser. Can be useful to copy and modify to base other parsers\n    on.\n    */\n    tokens) {\n        this.schema = schema;\n        this.tokenizer = tokenizer;\n        this.tokens = tokens;\n        this.tokenHandlers = tokenHandlers(schema, tokens);\n    }\n    /**\n    Parse a string as [CommonMark](http://commonmark.org/) markup,\n    and create a ProseMirror document as prescribed by this parser's\n    rules.\n    \n    The second argument, when given, is passed through to the\n    [Markdown\n    parser](https://markdown-it.github.io/markdown-it/#MarkdownIt.parse).\n    */\n    parse(text, markdownEnv = {}) {\n        let state = new MarkdownParseState(this.schema, this.tokenHandlers), doc;\n        state.parseTokens(this.tokenizer.parse(text, markdownEnv));\n        do {\n            doc = state.closeNode();\n        } while (state.stack.length);\n        return doc || this.schema.topNodeType.createAndFill();\n    }\n}\nfunction listIsTight(tokens, i) {\n    while (++i < tokens.length)\n        if (tokens[i].type != \"list_item_open\")\n            return tokens[i].hidden;\n    return false;\n}\n/**\nA parser parsing unextended [CommonMark](http://commonmark.org/),\nwithout inline HTML, and producing a document in the basic schema.\n*/\nconst defaultMarkdownParser = new MarkdownParser(schema, MarkdownIt(\"commonmark\", { html: false }), {\n    blockquote: { block: \"blockquote\" },\n    paragraph: { block: \"paragraph\" },\n    list_item: { block: \"list_item\" },\n    bullet_list: { block: \"bullet_list\", getAttrs: (_, tokens, i) => ({ tight: listIsTight(tokens, i) }) },\n    ordered_list: { block: \"ordered_list\", getAttrs: (tok, tokens, i) => ({\n            order: +tok.attrGet(\"start\") || 1,\n            tight: listIsTight(tokens, i)\n        }) },\n    heading: { block: \"heading\", getAttrs: tok => ({ level: +tok.tag.slice(1) }) },\n    code_block: { block: \"code_block\", noCloseToken: true },\n    fence: { block: \"code_block\", getAttrs: tok => ({ params: tok.info || \"\" }), noCloseToken: true },\n    hr: { node: \"horizontal_rule\" },\n    image: { node: \"image\", getAttrs: tok => ({\n            src: tok.attrGet(\"src\"),\n            title: tok.attrGet(\"title\") || null,\n            alt: tok.children[0] && tok.children[0].content || null\n        }) },\n    hardbreak: { node: \"hard_break\" },\n    em: { mark: \"em\" },\n    strong: { mark: \"strong\" },\n    link: { mark: \"link\", getAttrs: tok => ({\n            href: tok.attrGet(\"href\"),\n            title: tok.attrGet(\"title\") || null\n        }) },\n    code_inline: { mark: \"code\", noCloseToken: true }\n});\n\nconst blankMark = { open: \"\", close: \"\", mixable: true };\n/**\nA specification for serializing a ProseMirror document as\nMarkdown/CommonMark text.\n*/\nclass MarkdownSerializer {\n    /**\n    Construct a serializer with the given configuration. The `nodes`\n    object should map node names in a given schema to function that\n    take a serializer state and such a node, and serialize the node.\n    */\n    constructor(\n    /**\n    The node serializer functions for this serializer.\n    */\n    nodes, \n    /**\n    The mark serializer info.\n    */\n    marks, options = {}) {\n        this.nodes = nodes;\n        this.marks = marks;\n        this.options = options;\n    }\n    /**\n    Serialize the content of the given node to\n    [CommonMark](http://commonmark.org/).\n    */\n    serialize(content, options = {}) {\n        options = Object.assign({}, this.options, options);\n        let state = new MarkdownSerializerState(this.nodes, this.marks, options);\n        state.renderContent(content);\n        return state.out;\n    }\n}\n/**\nA serializer for the [basic schema](https://prosemirror.net/docs/ref/#schema).\n*/\nconst defaultMarkdownSerializer = new MarkdownSerializer({\n    blockquote(state, node) {\n        state.wrapBlock(\"> \", null, node, () => state.renderContent(node));\n    },\n    code_block(state, node) {\n        // Make sure the front matter fences are longer than any dash sequence within it\n        const backticks = node.textContent.match(/`{3,}/gm);\n        const fence = backticks ? (backticks.sort().slice(-1)[0] + \"`\") : \"```\";\n        state.write(fence + (node.attrs.params || \"\") + \"\\n\");\n        state.text(node.textContent, false);\n        // Add a newline to the current content before adding closing marker\n        state.write(\"\\n\");\n        state.write(fence);\n        state.closeBlock(node);\n    },\n    heading(state, node) {\n        state.write(state.repeat(\"#\", node.attrs.level) + \" \");\n        state.renderInline(node, false);\n        state.closeBlock(node);\n    },\n    horizontal_rule(state, node) {\n        state.write(node.attrs.markup || \"---\");\n        state.closeBlock(node);\n    },\n    bullet_list(state, node) {\n        state.renderList(node, \"  \", () => (node.attrs.bullet || \"*\") + \" \");\n    },\n    ordered_list(state, node) {\n        let start = node.attrs.order || 1;\n        let maxW = String(start + node.childCount - 1).length;\n        let space = state.repeat(\" \", maxW + 2);\n        state.renderList(node, space, i => {\n            let nStr = String(start + i);\n            return state.repeat(\" \", maxW - nStr.length) + nStr + \". \";\n        });\n    },\n    list_item(state, node) {\n        state.renderContent(node);\n    },\n    paragraph(state, node) {\n        state.renderInline(node);\n        state.closeBlock(node);\n    },\n    image(state, node) {\n        state.write(\"![\" + state.esc(node.attrs.alt || \"\") + \"](\" + node.attrs.src.replace(/[\\(\\)]/g, \"\\\\$&\") +\n            (node.attrs.title ? ' \"' + node.attrs.title.replace(/\"/g, '\\\\\"') + '\"' : \"\") + \")\");\n    },\n    hard_break(state, node, parent, index) {\n        for (let i = index + 1; i < parent.childCount; i++)\n            if (parent.child(i).type != node.type) {\n                state.write(\"\\\\\\n\");\n                return;\n            }\n    },\n    text(state, node) {\n        state.text(node.text, !state.inAutolink);\n    }\n}, {\n    em: { open: \"*\", close: \"*\", mixable: true, expelEnclosingWhitespace: true },\n    strong: { open: \"**\", close: \"**\", mixable: true, expelEnclosingWhitespace: true },\n    link: {\n        open(state, mark, parent, index) {\n            state.inAutolink = isPlainURL(mark, parent, index);\n            return state.inAutolink ? \"<\" : \"[\";\n        },\n        close(state, mark, parent, index) {\n            let { inAutolink } = state;\n            state.inAutolink = undefined;\n            return inAutolink ? \">\"\n                : \"](\" + mark.attrs.href.replace(/[\\(\\)\"]/g, \"\\\\$&\") + (mark.attrs.title ? ` \"${mark.attrs.title.replace(/\"/g, '\\\\\"')}\"` : \"\") + \")\";\n        },\n        mixable: true\n    },\n    code: { open(_state, _mark, parent, index) { return backticksFor(parent.child(index), -1); },\n        close(_state, _mark, parent, index) { return backticksFor(parent.child(index - 1), 1); },\n        escape: false }\n});\nfunction backticksFor(node, side) {\n    let ticks = /`+/g, m, len = 0;\n    if (node.isText)\n        while (m = ticks.exec(node.text))\n            len = Math.max(len, m[0].length);\n    let result = len > 0 && side > 0 ? \" `\" : \"`\";\n    for (let i = 0; i < len; i++)\n        result += \"`\";\n    if (len > 0 && side < 0)\n        result += \" \";\n    return result;\n}\nfunction isPlainURL(link, parent, index) {\n    if (link.attrs.title || !/^\\w+:/.test(link.attrs.href))\n        return false;\n    let content = parent.child(index);\n    if (!content.isText || content.text != link.attrs.href || content.marks[content.marks.length - 1] != link)\n        return false;\n    return index == parent.childCount - 1 || !link.isInSet(parent.child(index + 1).marks);\n}\n/**\nThis is an object used to track state and expose\nmethods related to markdown serialization. Instances are passed to\nnode and mark serialization methods (see `toMarkdown`).\n*/\nclass MarkdownSerializerState {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    nodes, \n    /**\n    @internal\n    */\n    marks, \n    /**\n    The options passed to the serializer.\n    */\n    options) {\n        this.nodes = nodes;\n        this.marks = marks;\n        this.options = options;\n        /**\n        @internal\n        */\n        this.delim = \"\";\n        /**\n        @internal\n        */\n        this.out = \"\";\n        /**\n        @internal\n        */\n        this.closed = null;\n        /**\n        @internal\n        */\n        this.inAutolink = undefined;\n        /**\n        @internal\n        */\n        this.atBlockStart = false;\n        /**\n        @internal\n        */\n        this.inTightList = false;\n        if (typeof this.options.tightLists == \"undefined\")\n            this.options.tightLists = false;\n        if (typeof this.options.hardBreakNodeName == \"undefined\")\n            this.options.hardBreakNodeName = \"hard_break\";\n    }\n    /**\n    @internal\n    */\n    flushClose(size = 2) {\n        if (this.closed) {\n            if (!this.atBlank())\n                this.out += \"\\n\";\n            if (size > 1) {\n                let delimMin = this.delim;\n                let trim = /\\s+$/.exec(delimMin);\n                if (trim)\n                    delimMin = delimMin.slice(0, delimMin.length - trim[0].length);\n                for (let i = 1; i < size; i++)\n                    this.out += delimMin + \"\\n\";\n            }\n            this.closed = null;\n        }\n    }\n    /**\n    @internal\n    */\n    getMark(name) {\n        let info = this.marks[name];\n        if (!info) {\n            if (this.options.strict !== false)\n                throw new Error(`Mark type \\`${name}\\` not supported by Markdown renderer`);\n            info = blankMark;\n        }\n        return info;\n    }\n    /**\n    Render a block, prefixing each line with `delim`, and the first\n    line in `firstDelim`. `node` should be the node that is closed at\n    the end of the block, and `f` is a function that renders the\n    content of the block.\n    */\n    wrapBlock(delim, firstDelim, node, f) {\n        let old = this.delim;\n        this.write(firstDelim != null ? firstDelim : delim);\n        this.delim += delim;\n        f();\n        this.delim = old;\n        this.closeBlock(node);\n    }\n    /**\n    @internal\n    */\n    atBlank() {\n        return /(^|\\n)$/.test(this.out);\n    }\n    /**\n    Ensure the current content ends with a newline.\n    */\n    ensureNewLine() {\n        if (!this.atBlank())\n            this.out += \"\\n\";\n    }\n    /**\n    Prepare the state for writing output (closing closed paragraphs,\n    adding delimiters, and so on), and then optionally add content\n    (unescaped) to the output.\n    */\n    write(content) {\n        this.flushClose();\n        if (this.delim && this.atBlank())\n            this.out += this.delim;\n        if (content)\n            this.out += content;\n    }\n    /**\n    Close the block for the given node.\n    */\n    closeBlock(node) {\n        this.closed = node;\n    }\n    /**\n    Add the given text to the document. When escape is not `false`,\n    it will be escaped.\n    */\n    text(text, escape = true) {\n        let lines = text.split(\"\\n\");\n        for (let i = 0; i < lines.length; i++) {\n            this.write();\n            // Escape exclamation marks in front of links\n            if (!escape && lines[i][0] == \"[\" && /(^|[^\\\\])\\!$/.test(this.out))\n                this.out = this.out.slice(0, this.out.length - 1) + \"\\\\!\";\n            this.out += escape ? this.esc(lines[i], this.atBlockStart) : lines[i];\n            if (i != lines.length - 1)\n                this.out += \"\\n\";\n        }\n    }\n    /**\n    Render the given node as a block.\n    */\n    render(node, parent, index) {\n        if (this.nodes[node.type.name]) {\n            this.nodes[node.type.name](this, node, parent, index);\n        }\n        else {\n            if (this.options.strict !== false) {\n                throw new Error(\"Token type `\" + node.type.name + \"` not supported by Markdown renderer\");\n            }\n            else if (!node.type.isLeaf) {\n                if (node.type.inlineContent)\n                    this.renderInline(node);\n                else\n                    this.renderContent(node);\n                if (node.isBlock)\n                    this.closeBlock(node);\n            }\n        }\n    }\n    /**\n    Render the contents of `parent` as block nodes.\n    */\n    renderContent(parent) {\n        parent.forEach((node, _, i) => this.render(node, parent, i));\n    }\n    /**\n    Render the contents of `parent` as inline content.\n    */\n    renderInline(parent, fromBlockStart = true) {\n        this.atBlockStart = fromBlockStart;\n        let active = [], trailing = \"\";\n        let progress = (node, offset, index) => {\n            let marks = node ? node.marks : [];\n            // Remove marks from `hard_break` that are the last node inside\n            // that mark to prevent parser edge cases with new lines just\n            // before closing marks.\n            if (node && node.type.name === this.options.hardBreakNodeName)\n                marks = marks.filter(m => {\n                    if (index + 1 == parent.childCount)\n                        return false;\n                    let next = parent.child(index + 1);\n                    return m.isInSet(next.marks) && (!next.isText || /\\S/.test(next.text));\n                });\n            let leading = trailing;\n            trailing = \"\";\n            // If whitespace has to be expelled from the node, adjust\n            // leading and trailing accordingly.\n            if (node && node.isText && marks.some(mark => {\n                let info = this.getMark(mark.type.name);\n                return info && info.expelEnclosingWhitespace && !mark.isInSet(active);\n            })) {\n                let [_, lead, rest] = /^(\\s*)(.*)$/m.exec(node.text);\n                if (lead) {\n                    leading += lead;\n                    node = rest ? node.withText(rest) : null;\n                    if (!node)\n                        marks = active;\n                }\n            }\n            if (node && node.isText && marks.some(mark => {\n                let info = this.getMark(mark.type.name);\n                return info && info.expelEnclosingWhitespace &&\n                    (index == parent.childCount - 1 || !mark.isInSet(parent.child(index + 1).marks));\n            })) {\n                let [_, rest, trail] = /^(.*?)(\\s*)$/m.exec(node.text);\n                if (trail) {\n                    trailing = trail;\n                    node = rest ? node.withText(rest) : null;\n                    if (!node)\n                        marks = active;\n                }\n            }\n            let inner = marks.length ? marks[marks.length - 1] : null;\n            let noEsc = inner && this.getMark(inner.type.name).escape === false;\n            let len = marks.length - (noEsc ? 1 : 0);\n            // Try to reorder 'mixable' marks, such as em and strong, which\n            // in Markdown may be opened and closed in different order, so\n            // that order of the marks for the token matches the order in\n            // active.\n            outer: for (let i = 0; i < len; i++) {\n                let mark = marks[i];\n                if (!this.getMark(mark.type.name).mixable)\n                    break;\n                for (let j = 0; j < active.length; j++) {\n                    let other = active[j];\n                    if (!this.getMark(other.type.name).mixable)\n                        break;\n                    if (mark.eq(other)) {\n                        if (i > j)\n                            marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len));\n                        else if (j > i)\n                            marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len));\n                        continue outer;\n                    }\n                }\n            }\n            // Find the prefix of the mark set that didn't change\n            let keep = 0;\n            while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep]))\n                ++keep;\n            // Close the marks that need to be closed\n            while (keep < active.length)\n                this.text(this.markString(active.pop(), false, parent, index), false);\n            // Output any previously expelled trailing whitespace outside the marks\n            if (leading)\n                this.text(leading);\n            // Open the marks that need to be opened\n            if (node) {\n                while (active.length < len) {\n                    let add = marks[active.length];\n                    active.push(add);\n                    this.text(this.markString(add, true, parent, index), false);\n                    this.atBlockStart = false;\n                }\n                // Render the node. Special case code marks, since their content\n                // may not be escaped.\n                if (noEsc && node.isText)\n                    this.text(this.markString(inner, true, parent, index) + node.text +\n                        this.markString(inner, false, parent, index + 1), false);\n                else\n                    this.render(node, parent, index);\n                this.atBlockStart = false;\n            }\n            // After the first non-empty text node is rendered, the end of output\n            // is no longer at block start.\n            //\n            // FIXME: If a non-text node writes something to the output for this\n            // block, the end of output is also no longer at block start. But how\n            // can we detect that?\n            if ((node === null || node === void 0 ? void 0 : node.isText) && node.nodeSize > 0) {\n                this.atBlockStart = false;\n            }\n        };\n        parent.forEach(progress);\n        progress(null, 0, parent.childCount);\n        this.atBlockStart = false;\n    }\n    /**\n    Render a node's content as a list. `delim` should be the extra\n    indentation added to all lines except the first in an item,\n    `firstDelim` is a function going from an item index to a\n    delimiter for the first line of the item.\n    */\n    renderList(node, delim, firstDelim) {\n        if (this.closed && this.closed.type == node.type)\n            this.flushClose(3);\n        else if (this.inTightList)\n            this.flushClose(1);\n        let isTight = typeof node.attrs.tight != \"undefined\" ? node.attrs.tight : this.options.tightLists;\n        let prevTight = this.inTightList;\n        this.inTightList = isTight;\n        node.forEach((child, _, i) => {\n            if (i && isTight)\n                this.flushClose(1);\n            this.wrapBlock(delim, firstDelim(i), node, () => this.render(child, node, i));\n        });\n        this.inTightList = prevTight;\n    }\n    /**\n    Escape the given string so that it can safely appear in Markdown\n    content. If `startOfLine` is true, also escape characters that\n    have special meaning only at the start of the line.\n    */\n    esc(str, startOfLine = false) {\n        str = str.replace(/[`*\\\\~\\[\\]_]/g, (m, i) => m == \"_\" && i > 0 && i + 1 < str.length && str[i - 1].match(/\\w/) && str[i + 1].match(/\\w/) ? m : \"\\\\\" + m);\n        if (startOfLine)\n            str = str.replace(/^(\\+[ ]|[\\-*>])/, \"\\\\$&\").replace(/^(\\s*)(#{1,6})(\\s|$)/, '$1\\\\$2$3').replace(/^(\\s*\\d+)\\.\\s/, \"$1\\\\. \");\n        if (this.options.escapeExtraCharacters)\n            str = str.replace(this.options.escapeExtraCharacters, \"\\\\$&\");\n        return str;\n    }\n    /**\n    @internal\n    */\n    quote(str) {\n        let wrap = str.indexOf('\"') == -1 ? '\"\"' : str.indexOf(\"'\") == -1 ? \"''\" : \"()\";\n        return wrap[0] + str + wrap[1];\n    }\n    /**\n    Repeat the given string `n` times.\n    */\n    repeat(str, n) {\n        let out = \"\";\n        for (let i = 0; i < n; i++)\n            out += str;\n        return out;\n    }\n    /**\n    Get the markdown string for a given opening or closing mark.\n    */\n    markString(mark, open, parent, index) {\n        let info = this.getMark(mark.type.name);\n        let value = open ? info.open : info.close;\n        return typeof value == \"string\" ? value : value(this, mark, parent, index);\n    }\n    /**\n    Get leading and trailing whitespace from a string. Values of\n    leading or trailing property of the return object will be undefined\n    if there is no match.\n    */\n    getEnclosingWhitespace(text) {\n        return {\n            leading: (text.match(/^(\\s+)/) || [undefined])[0],\n            trailing: (text.match(/(\\s+)$/) || [undefined])[0]\n        };\n    }\n}\n\nexport { MarkdownParser, MarkdownSerializer, MarkdownSerializerState, defaultMarkdownParser, defaultMarkdownSerializer, schema };\n"],
  "mappings": ";;;;;;;;;;AAMA,IAAM,SAAS,IAAI,OAAO;AAAA,EACtB,OAAO;AAAA,IACH,KAAK;AAAA,MACD,SAAS;AAAA,IACb;AAAA,IACA,WAAW;AAAA,MACP,SAAS;AAAA,MACT,OAAO;AAAA,MACP,UAAU,CAAC,EAAE,KAAK,IAAI,CAAC;AAAA,MACvB,QAAQ;AAAE,eAAO,CAAC,KAAK,CAAC;AAAA,MAAG;AAAA,IAC/B;AAAA,IACA,YAAY;AAAA,MACR,SAAS;AAAA,MACT,OAAO;AAAA,MACP,UAAU,CAAC,EAAE,KAAK,aAAa,CAAC;AAAA,MAChC,QAAQ;AAAE,eAAO,CAAC,cAAc,CAAC;AAAA,MAAG;AAAA,IACxC;AAAA,IACA,iBAAiB;AAAA,MACb,OAAO;AAAA,MACP,UAAU,CAAC,EAAE,KAAK,KAAK,CAAC;AAAA,MACxB,QAAQ;AAAE,eAAO,CAAC,OAAO,CAAC,IAAI,CAAC;AAAA,MAAG;AAAA,IACtC;AAAA,IACA,SAAS;AAAA,MACL,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,EAAE;AAAA,MAC/B,SAAS;AAAA,MACT,OAAO;AAAA,MACP,UAAU;AAAA,MACV,UAAU;AAAA,QAAC,EAAE,KAAK,MAAM,OAAO,EAAE,OAAO,EAAE,EAAE;AAAA,QACxC,EAAE,KAAK,MAAM,OAAO,EAAE,OAAO,EAAE,EAAE;AAAA,QACjC,EAAE,KAAK,MAAM,OAAO,EAAE,OAAO,EAAE,EAAE;AAAA,QACjC,EAAE,KAAK,MAAM,OAAO,EAAE,OAAO,EAAE,EAAE;AAAA,QACjC,EAAE,KAAK,MAAM,OAAO,EAAE,OAAO,EAAE,EAAE;AAAA,QACjC,EAAE,KAAK,MAAM,OAAO,EAAE,OAAO,EAAE,EAAE;AAAA,MAAC;AAAA,MACtC,MAAM,MAAM;AAAE,eAAO,CAAC,MAAM,KAAK,MAAM,OAAO,CAAC;AAAA,MAAG;AAAA,IACtD;AAAA,IACA,YAAY;AAAA,MACR,SAAS;AAAA,MACT,OAAO;AAAA,MACP,MAAM;AAAA,MACN,UAAU;AAAA,MACV,OAAO;AAAA,MACP,OAAO,EAAE,QAAQ,EAAE,SAAS,GAAG,EAAE;AAAA,MACjC,UAAU,CAAC,EAAE,KAAK,OAAO,oBAAoB,QAAQ,UAAU,WAAS,EAAE,QAAQ,KAAK,aAAa,aAAa,KAAK,GAAG,GAAG,CAAC;AAAA,MAC7H,MAAM,MAAM;AAAE,eAAO,CAAC,OAAO,KAAK,MAAM,SAAS,EAAE,eAAe,KAAK,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAAA,MAAG;AAAA,IAC9G;AAAA,IACA,cAAc;AAAA,MACV,SAAS;AAAA,MACT,OAAO;AAAA,MACP,OAAO,EAAE,OAAO,EAAE,SAAS,EAAE,GAAG,OAAO,EAAE,SAAS,MAAM,EAAE;AAAA,MAC1D,UAAU,CAAC,EAAE,KAAK,MAAM,SAAS,KAAK;AAC1B,eAAO;AAAA,UAAE,OAAO,IAAI,aAAa,OAAO,IAAI,CAAC,IAAI,aAAa,OAAO,IAAI;AAAA,UACrE,OAAO,IAAI,aAAa,YAAY;AAAA,QAAE;AAAA,MAC9C,EAAE,CAAC;AAAA,MACX,MAAM,MAAM;AACR,eAAO,CAAC,MAAM;AAAA,UAAE,OAAO,KAAK,MAAM,SAAS,IAAI,OAAO,KAAK,MAAM;AAAA,UACzD,cAAc,KAAK,MAAM,QAAQ,SAAS;AAAA,QAAK,GAAG,CAAC;AAAA,MAC/D;AAAA,IACJ;AAAA,IACA,aAAa;AAAA,MACT,SAAS;AAAA,MACT,OAAO;AAAA,MACP,OAAO,EAAE,OAAO,EAAE,SAAS,MAAM,EAAE;AAAA,MACnC,UAAU,CAAC,EAAE,KAAK,MAAM,UAAU,UAAQ,EAAE,OAAO,IAAI,aAAa,YAAY,EAAE,GAAG,CAAC;AAAA,MACtF,MAAM,MAAM;AAAE,eAAO,CAAC,MAAM,EAAE,cAAc,KAAK,MAAM,QAAQ,SAAS,KAAK,GAAG,CAAC;AAAA,MAAG;AAAA,IACxF;AAAA,IACA,WAAW;AAAA,MACP,SAAS;AAAA,MACT,UAAU;AAAA,MACV,UAAU,CAAC,EAAE,KAAK,KAAK,CAAC;AAAA,MACxB,QAAQ;AAAE,eAAO,CAAC,MAAM,CAAC;AAAA,MAAG;AAAA,IAChC;AAAA,IACA,MAAM;AAAA,MACF,OAAO;AAAA,IACX;AAAA,IACA,OAAO;AAAA,MACH,QAAQ;AAAA,MACR,OAAO;AAAA,QACH,KAAK,CAAC;AAAA,QACN,KAAK,EAAE,SAAS,KAAK;AAAA,QACrB,OAAO,EAAE,SAAS,KAAK;AAAA,MAC3B;AAAA,MACA,OAAO;AAAA,MACP,WAAW;AAAA,MACX,UAAU,CAAC,EAAE,KAAK,YAAY,SAAS,KAAK;AAChC,eAAO;AAAA,UACH,KAAK,IAAI,aAAa,KAAK;AAAA,UAC3B,OAAO,IAAI,aAAa,OAAO;AAAA,UAC/B,KAAK,IAAI,aAAa,KAAK;AAAA,QAC/B;AAAA,MACJ,EAAE,CAAC;AAAA,MACX,MAAM,MAAM;AAAE,eAAO,CAAC,OAAO,KAAK,KAAK;AAAA,MAAG;AAAA,IAC9C;AAAA,IACA,YAAY;AAAA,MACR,QAAQ;AAAA,MACR,OAAO;AAAA,MACP,YAAY;AAAA,MACZ,UAAU,CAAC,EAAE,KAAK,KAAK,CAAC;AAAA,MACxB,QAAQ;AAAE,eAAO,CAAC,IAAI;AAAA,MAAG;AAAA,IAC7B;AAAA,EACJ;AAAA,EACA,OAAO;AAAA,IACH,IAAI;AAAA,MACA,UAAU;AAAA,QACN,EAAE,KAAK,IAAI;AAAA,QAAG,EAAE,KAAK,KAAK;AAAA,QAC1B,EAAE,OAAO,oBAAoB;AAAA,QAC7B,EAAE,OAAO,qBAAqB,WAAW,OAAK,EAAE,KAAK,QAAQ,KAAK;AAAA,MACtE;AAAA,MACA,QAAQ;AAAE,eAAO,CAAC,IAAI;AAAA,MAAG;AAAA,IAC7B;AAAA,IACA,QAAQ;AAAA,MACJ,UAAU;AAAA,QACN,EAAE,KAAK,SAAS;AAAA,QAChB,EAAE,KAAK,KAAK,UAAU,UAAQ,KAAK,MAAM,cAAc,YAAY,KAAK;AAAA,QACxE,EAAE,OAAO,mBAAmB,WAAW,OAAK,EAAE,KAAK,QAAQ,SAAS;AAAA,QACpE,EAAE,OAAO,eAAe,UAAU,WAAS,4BAA4B,KAAK,KAAK,KAAK,KAAK;AAAA,MAC/F;AAAA,MACA,QAAQ;AAAE,eAAO,CAAC,QAAQ;AAAA,MAAG;AAAA,IACjC;AAAA,IACA,MAAM;AAAA,MACF,OAAO;AAAA,QACH,MAAM,CAAC;AAAA,QACP,OAAO,EAAE,SAAS,KAAK;AAAA,MAC3B;AAAA,MACA,WAAW;AAAA,MACX,UAAU,CAAC,EAAE,KAAK,WAAW,SAAS,KAAK;AAC/B,eAAO,EAAE,MAAM,IAAI,aAAa,MAAM,GAAG,OAAO,IAAI,aAAa,OAAO,EAAE;AAAA,MAC9E,EAAE,CAAC;AAAA,MACX,MAAM,MAAM;AAAE,eAAO,CAAC,KAAK,KAAK,KAAK;AAAA,MAAG;AAAA,IAC5C;AAAA,IACA,MAAM;AAAA,MACF,MAAM;AAAA,MACN,UAAU,CAAC,EAAE,KAAK,OAAO,CAAC;AAAA,MAC1B,QAAQ;AAAE,eAAO,CAAC,MAAM;AAAA,MAAG;AAAA,IAC/B;AAAA,EACJ;AACJ,CAAC;AAGD,SAAS,WAAW,GAAG,GAAG;AACtB,MAAI,EAAE,UAAU,EAAE,UAAU,KAAK,QAAQ,EAAE,OAAO,EAAE,KAAK;AACrD,WAAO,EAAE,SAAS,EAAE,OAAO,EAAE,IAAI;AACzC;AAEA,IAAM,qBAAN,MAAyB;AAAA,EACrB,YAAYA,SAAQC,gBAAe;AAC/B,SAAK,SAASD;AACd,SAAK,gBAAgBC;AACrB,SAAK,QAAQ,CAAC,EAAE,MAAMD,QAAO,aAAa,OAAO,MAAM,SAAS,CAAC,GAAG,OAAO,KAAK,KAAK,CAAC;AAAA,EAC1F;AAAA,EACA,MAAM;AACF,WAAO,KAAK,MAAM,KAAK,MAAM,SAAS,CAAC;AAAA,EAC3C;AAAA,EACA,KAAK,KAAK;AACN,QAAI,KAAK,MAAM;AACX,WAAK,IAAI,EAAE,QAAQ,KAAK,GAAG;AAAA,EACnC;AAAA;AAAA;AAAA,EAGA,QAAQ,MAAM;AACV,QAAI,CAAC;AACD;AACJ,QAAI,MAAM,KAAK,IAAI,GAAG,QAAQ,IAAI,SAAS,OAAO,MAAM,MAAM,SAAS,CAAC;AACxE,QAAI,OAAO,KAAK,OAAO,KAAK,MAAM,IAAI,KAAK,GAAG;AAC9C,QAAI,SAAS,SAAS,WAAW,MAAM,IAAI;AACvC,YAAM,MAAM,SAAS,CAAC,IAAI;AAAA;AAE1B,YAAM,KAAK,IAAI;AAAA,EACvB;AAAA;AAAA,EAEA,SAAS,MAAM;AACX,QAAI,MAAM,KAAK,IAAI;AACnB,QAAI,QAAQ,KAAK,SAAS,IAAI,KAAK;AAAA,EACvC;AAAA;AAAA,EAEA,UAAU,MAAM;AACZ,QAAI,MAAM,KAAK,IAAI;AACnB,QAAI,QAAQ,KAAK,cAAc,IAAI,KAAK;AAAA,EAC5C;AAAA,EACA,YAAY,MAAM;AACd,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AAClC,UAAI,MAAM,KAAK,CAAC;AAChB,UAAI,UAAU,KAAK,cAAc,IAAI,IAAI;AACzC,UAAI,CAAC;AACD,cAAM,IAAI,MAAM,iBAAiB,IAAI,OAAO,oCAAoC;AACpF,cAAQ,MAAM,KAAK,MAAM,CAAC;AAAA,IAC9B;AAAA,EACJ;AAAA;AAAA,EAEA,QAAQ,MAAME,QAAO,SAAS;AAC1B,QAAI,MAAM,KAAK,IAAI;AACnB,QAAI,OAAO,KAAK,cAAcA,QAAO,SAAS,MAAM,IAAI,QAAQ,CAAC,CAAC;AAClE,QAAI,CAAC;AACD,aAAO;AACX,SAAK,KAAK,IAAI;AACd,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,SAAS,MAAMA,QAAO;AAClB,SAAK,MAAM,KAAK,EAAE,MAAY,OAAOA,QAAO,SAAS,CAAC,GAAG,OAAO,KAAK,KAAK,CAAC;AAAA,EAC/E;AAAA;AAAA,EAEA,YAAY;AACR,QAAI,OAAO,KAAK,MAAM,IAAI;AAC1B,WAAO,KAAK,QAAQ,KAAK,MAAM,KAAK,OAAO,KAAK,OAAO;AAAA,EAC3D;AACJ;AACA,SAAS,MAAM,MAAM,OAAO,QAAQ,GAAG;AACnC,MAAI,KAAK;AACL,WAAO,KAAK,SAAS,OAAO,QAAQ,CAAC;AAAA,WAEhC,KAAK,iBAAiB;AAC3B,WAAO,KAAK,MAAM,KAAK;AAAA;AAEvB,WAAO,KAAK;AACpB;AAGA,SAAS,aAAa,MAAM,MAAM;AAC9B,SAAO,KAAK,gBAAgB,QAAQ,iBAAiB,QAAQ,gBAAgB,QAAQ;AACzF;AACA,SAAS,uBAAuB,KAAK;AACjC,SAAO,IAAI,IAAI,SAAS,CAAC,KAAK,OAAO,IAAI,MAAM,GAAG,IAAI,SAAS,CAAC,IAAI;AACxE;AACA,SAAS,OAAO;AAAE;AAClB,SAAS,cAAcF,SAAQ,QAAQ;AACnC,MAAI,WAAW,uBAAO,OAAO,IAAI;AACjC,WAAS,QAAQ,QAAQ;AACrB,QAAI,OAAO,OAAO,IAAI;AACtB,QAAI,KAAK,OAAO;AACZ,UAAI,WAAWA,QAAO,SAAS,KAAK,KAAK;AACzC,UAAI,aAAa,MAAM,IAAI,GAAG;AAC1B,iBAAS,IAAI,IAAI,CAAC,OAAO,KAAKG,SAAQ,MAAM;AACxC,gBAAM,SAAS,UAAU,MAAM,MAAM,KAAKA,SAAQ,CAAC,CAAC;AACpD,gBAAM,QAAQ,uBAAuB,IAAI,OAAO,CAAC;AACjD,gBAAM,UAAU;AAAA,QACpB;AAAA,MACJ,OACK;AACD,iBAAS,OAAO,OAAO,IAAI,CAAC,OAAO,KAAKA,SAAQ,MAAM,MAAM,SAAS,UAAU,MAAM,MAAM,KAAKA,SAAQ,CAAC,CAAC;AAC1G,iBAAS,OAAO,QAAQ,IAAI,WAAS,MAAM,UAAU;AAAA,MACzD;AAAA,IACJ,WACS,KAAK,MAAM;AAChB,UAAI,WAAWH,QAAO,SAAS,KAAK,IAAI;AACxC,eAAS,IAAI,IAAI,CAAC,OAAO,KAAKG,SAAQ,MAAM,MAAM,QAAQ,UAAU,MAAM,MAAM,KAAKA,SAAQ,CAAC,CAAC;AAAA,IACnG,WACS,KAAK,MAAM;AAChB,UAAI,WAAWH,QAAO,MAAM,KAAK,IAAI;AACrC,UAAI,aAAa,MAAM,IAAI,GAAG;AAC1B,iBAAS,IAAI,IAAI,CAAC,OAAO,KAAKG,SAAQ,MAAM;AACxC,gBAAM,SAAS,SAAS,OAAO,MAAM,MAAM,KAAKA,SAAQ,CAAC,CAAC,CAAC;AAC3D,gBAAM,QAAQ,uBAAuB,IAAI,OAAO,CAAC;AACjD,gBAAM,UAAU,QAAQ;AAAA,QAC5B;AAAA,MACJ,OACK;AACD,iBAAS,OAAO,OAAO,IAAI,CAAC,OAAO,KAAKA,SAAQ,MAAM,MAAM,SAAS,SAAS,OAAO,MAAM,MAAM,KAAKA,SAAQ,CAAC,CAAC,CAAC;AACjH,iBAAS,OAAO,QAAQ,IAAI,WAAS,MAAM,UAAU,QAAQ;AAAA,MACjE;AAAA,IACJ,WACS,KAAK,QAAQ;AAClB,UAAI,aAAa,MAAM,IAAI,GAAG;AAC1B,iBAAS,IAAI,IAAI;AAAA,MACrB,OACK;AACD,iBAAS,OAAO,OAAO,IAAI;AAC3B,iBAAS,OAAO,QAAQ,IAAI;AAAA,MAChC;AAAA,IACJ,OACK;AACD,YAAM,IAAI,WAAW,+BAA+B,KAAK,UAAU,IAAI,CAAC;AAAA,IAC5E;AAAA,EACJ;AACA,WAAS,OAAO,CAAC,OAAO,QAAQ,MAAM,QAAQ,IAAI,OAAO;AACzD,WAAS,SAAS,CAAC,OAAO,QAAQ,MAAM,YAAY,IAAI,QAAQ;AAChE,WAAS,YAAY,SAAS,cAAc,WAAS,MAAM,QAAQ,GAAG;AACtE,SAAO;AACX;AAOA,IAAM,iBAAN,MAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASjB,YAIAH,SAIA,WAMA,QAAQ;AACJ,SAAK,SAASA;AACd,SAAK,YAAY;AACjB,SAAK,SAAS;AACd,SAAK,gBAAgB,cAAcA,SAAQ,MAAM;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,MAAM,cAAc,CAAC,GAAG;AAC1B,QAAI,QAAQ,IAAI,mBAAmB,KAAK,QAAQ,KAAK,aAAa,GAAG;AACrE,UAAM,YAAY,KAAK,UAAU,MAAM,MAAM,WAAW,CAAC;AACzD,OAAG;AACC,YAAM,MAAM,UAAU;AAAA,IAC1B,SAAS,MAAM,MAAM;AACrB,WAAO,OAAO,KAAK,OAAO,YAAY,cAAc;AAAA,EACxD;AACJ;AACA,SAAS,YAAY,QAAQ,GAAG;AAC5B,SAAO,EAAE,IAAI,OAAO;AAChB,QAAI,OAAO,CAAC,EAAE,QAAQ;AAClB,aAAO,OAAO,CAAC,EAAE;AACzB,SAAO;AACX;AAKA,IAAM,wBAAwB,IAAI,eAAe,QAAQ,YAAW,cAAc,EAAE,MAAM,MAAM,CAAC,GAAG;AAAA,EAChG,YAAY,EAAE,OAAO,aAAa;AAAA,EAClC,WAAW,EAAE,OAAO,YAAY;AAAA,EAChC,WAAW,EAAE,OAAO,YAAY;AAAA,EAChC,aAAa,EAAE,OAAO,eAAe,UAAU,CAAC,GAAG,QAAQ,OAAO,EAAE,OAAO,YAAY,QAAQ,CAAC,EAAE,GAAG;AAAA,EACrG,cAAc,EAAE,OAAO,gBAAgB,UAAU,CAAC,KAAK,QAAQ,OAAO;AAAA,IAC9D,OAAO,CAAC,IAAI,QAAQ,OAAO,KAAK;AAAA,IAChC,OAAO,YAAY,QAAQ,CAAC;AAAA,EAChC,GAAG;AAAA,EACP,SAAS,EAAE,OAAO,WAAW,UAAU,UAAQ,EAAE,OAAO,CAAC,IAAI,IAAI,MAAM,CAAC,EAAE,GAAG;AAAA,EAC7E,YAAY,EAAE,OAAO,cAAc,cAAc,KAAK;AAAA,EACtD,OAAO,EAAE,OAAO,cAAc,UAAU,UAAQ,EAAE,QAAQ,IAAI,QAAQ,GAAG,IAAI,cAAc,KAAK;AAAA,EAChG,IAAI,EAAE,MAAM,kBAAkB;AAAA,EAC9B,OAAO,EAAE,MAAM,SAAS,UAAU,UAAQ;AAAA,IAClC,KAAK,IAAI,QAAQ,KAAK;AAAA,IACtB,OAAO,IAAI,QAAQ,OAAO,KAAK;AAAA,IAC/B,KAAK,IAAI,SAAS,CAAC,KAAK,IAAI,SAAS,CAAC,EAAE,WAAW;AAAA,EACvD,GAAG;AAAA,EACP,WAAW,EAAE,MAAM,aAAa;AAAA,EAChC,IAAI,EAAE,MAAM,KAAK;AAAA,EACjB,QAAQ,EAAE,MAAM,SAAS;AAAA,EACzB,MAAM,EAAE,MAAM,QAAQ,UAAU,UAAQ;AAAA,IAChC,MAAM,IAAI,QAAQ,MAAM;AAAA,IACxB,OAAO,IAAI,QAAQ,OAAO,KAAK;AAAA,EACnC,GAAG;AAAA,EACP,aAAa,EAAE,MAAM,QAAQ,cAAc,KAAK;AACpD,CAAC;AAED,IAAM,YAAY,EAAE,MAAM,IAAI,OAAO,IAAI,SAAS,KAAK;AAKvD,IAAM,qBAAN,MAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMrB,YAIA,OAIA,OAAO,UAAU,CAAC,GAAG;AACjB,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,SAAK,UAAU;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,UAAU,SAAS,UAAU,CAAC,GAAG;AAC7B,cAAU,OAAO,OAAO,CAAC,GAAG,KAAK,SAAS,OAAO;AACjD,QAAI,QAAQ,IAAI,wBAAwB,KAAK,OAAO,KAAK,OAAO,OAAO;AACvE,UAAM,cAAc,OAAO;AAC3B,WAAO,MAAM;AAAA,EACjB;AACJ;AAIA,IAAM,4BAA4B,IAAI,mBAAmB;AAAA,EACrD,WAAW,OAAO,MAAM;AACpB,UAAM,UAAU,MAAM,MAAM,MAAM,MAAM,MAAM,cAAc,IAAI,CAAC;AAAA,EACrE;AAAA,EACA,WAAW,OAAO,MAAM;AAEpB,UAAM,YAAY,KAAK,YAAY,MAAM,SAAS;AAClD,UAAM,QAAQ,YAAa,UAAU,KAAK,EAAE,MAAM,EAAE,EAAE,CAAC,IAAI,MAAO;AAClE,UAAM,MAAM,SAAS,KAAK,MAAM,UAAU,MAAM,IAAI;AACpD,UAAM,KAAK,KAAK,aAAa,KAAK;AAElC,UAAM,MAAM,IAAI;AAChB,UAAM,MAAM,KAAK;AACjB,UAAM,WAAW,IAAI;AAAA,EACzB;AAAA,EACA,QAAQ,OAAO,MAAM;AACjB,UAAM,MAAM,MAAM,OAAO,KAAK,KAAK,MAAM,KAAK,IAAI,GAAG;AACrD,UAAM,aAAa,MAAM,KAAK;AAC9B,UAAM,WAAW,IAAI;AAAA,EACzB;AAAA,EACA,gBAAgB,OAAO,MAAM;AACzB,UAAM,MAAM,KAAK,MAAM,UAAU,KAAK;AACtC,UAAM,WAAW,IAAI;AAAA,EACzB;AAAA,EACA,YAAY,OAAO,MAAM;AACrB,UAAM,WAAW,MAAM,MAAM,OAAO,KAAK,MAAM,UAAU,OAAO,GAAG;AAAA,EACvE;AAAA,EACA,aAAa,OAAO,MAAM;AACtB,QAAI,QAAQ,KAAK,MAAM,SAAS;AAChC,QAAI,OAAO,OAAO,QAAQ,KAAK,aAAa,CAAC,EAAE;AAC/C,QAAI,QAAQ,MAAM,OAAO,KAAK,OAAO,CAAC;AACtC,UAAM,WAAW,MAAM,OAAO,OAAK;AAC/B,UAAI,OAAO,OAAO,QAAQ,CAAC;AAC3B,aAAO,MAAM,OAAO,KAAK,OAAO,KAAK,MAAM,IAAI,OAAO;AAAA,IAC1D,CAAC;AAAA,EACL;AAAA,EACA,UAAU,OAAO,MAAM;AACnB,UAAM,cAAc,IAAI;AAAA,EAC5B;AAAA,EACA,UAAU,OAAO,MAAM;AACnB,UAAM,aAAa,IAAI;AACvB,UAAM,WAAW,IAAI;AAAA,EACzB;AAAA,EACA,MAAM,OAAO,MAAM;AACf,UAAM,MAAM,OAAO,MAAM,IAAI,KAAK,MAAM,OAAO,EAAE,IAAI,OAAO,KAAK,MAAM,IAAI,QAAQ,WAAW,MAAM,KAC/F,KAAK,MAAM,QAAQ,OAAO,KAAK,MAAM,MAAM,QAAQ,MAAM,KAAK,IAAI,MAAM,MAAM,GAAG;AAAA,EAC1F;AAAA,EACA,WAAW,OAAO,MAAM,QAAQ,OAAO;AACnC,aAAS,IAAI,QAAQ,GAAG,IAAI,OAAO,YAAY;AAC3C,UAAI,OAAO,MAAM,CAAC,EAAE,QAAQ,KAAK,MAAM;AACnC,cAAM,MAAM,MAAM;AAClB;AAAA,MACJ;AAAA,EACR;AAAA,EACA,KAAK,OAAO,MAAM;AACd,UAAM,KAAK,KAAK,MAAM,CAAC,MAAM,UAAU;AAAA,EAC3C;AACJ,GAAG;AAAA,EACC,IAAI,EAAE,MAAM,KAAK,OAAO,KAAK,SAAS,MAAM,0BAA0B,KAAK;AAAA,EAC3E,QAAQ,EAAE,MAAM,MAAM,OAAO,MAAM,SAAS,MAAM,0BAA0B,KAAK;AAAA,EACjF,MAAM;AAAA,IACF,KAAK,OAAO,MAAM,QAAQ,OAAO;AAC7B,YAAM,aAAa,WAAW,MAAM,QAAQ,KAAK;AACjD,aAAO,MAAM,aAAa,MAAM;AAAA,IACpC;AAAA,IACA,MAAM,OAAO,MAAM,QAAQ,OAAO;AAC9B,UAAI,EAAE,WAAW,IAAI;AACrB,YAAM,aAAa;AACnB,aAAO,aAAa,MACd,OAAO,KAAK,MAAM,KAAK,QAAQ,YAAY,MAAM,KAAK,KAAK,MAAM,QAAQ,KAAK,KAAK,MAAM,MAAM,QAAQ,MAAM,KAAK,CAAC,MAAM,MAAM;AAAA,IACzI;AAAA,IACA,SAAS;AAAA,EACb;AAAA,EACA,MAAM;AAAA,IAAE,KAAK,QAAQ,OAAO,QAAQ,OAAO;AAAE,aAAO,aAAa,OAAO,MAAM,KAAK,GAAG,EAAE;AAAA,IAAG;AAAA,IACvF,MAAM,QAAQ,OAAO,QAAQ,OAAO;AAAE,aAAO,aAAa,OAAO,MAAM,QAAQ,CAAC,GAAG,CAAC;AAAA,IAAG;AAAA,IACvF,QAAQ;AAAA,EAAM;AACtB,CAAC;AACD,SAAS,aAAa,MAAM,MAAM;AAC9B,MAAI,QAAQ,OAAO,GAAG,MAAM;AAC5B,MAAI,KAAK;AACL,WAAO,IAAI,MAAM,KAAK,KAAK,IAAI;AAC3B,YAAM,KAAK,IAAI,KAAK,EAAE,CAAC,EAAE,MAAM;AACvC,MAAI,SAAS,MAAM,KAAK,OAAO,IAAI,OAAO;AAC1C,WAAS,IAAI,GAAG,IAAI,KAAK;AACrB,cAAU;AACd,MAAI,MAAM,KAAK,OAAO;AAClB,cAAU;AACd,SAAO;AACX;AACA,SAAS,WAAW,MAAM,QAAQ,OAAO;AACrC,MAAI,KAAK,MAAM,SAAS,CAAC,QAAQ,KAAK,KAAK,MAAM,IAAI;AACjD,WAAO;AACX,MAAI,UAAU,OAAO,MAAM,KAAK;AAChC,MAAI,CAAC,QAAQ,UAAU,QAAQ,QAAQ,KAAK,MAAM,QAAQ,QAAQ,MAAM,QAAQ,MAAM,SAAS,CAAC,KAAK;AACjG,WAAO;AACX,SAAO,SAAS,OAAO,aAAa,KAAK,CAAC,KAAK,QAAQ,OAAO,MAAM,QAAQ,CAAC,EAAE,KAAK;AACxF;AAMA,IAAM,0BAAN,MAA8B;AAAA;AAAA;AAAA;AAAA,EAI1B,YAIA,OAIA,OAIA,SAAS;AACL,SAAK,QAAQ;AACb,SAAK,QAAQ;AACb,SAAK,UAAU;AAIf,SAAK,QAAQ;AAIb,SAAK,MAAM;AAIX,SAAK,SAAS;AAId,SAAK,aAAa;AAIlB,SAAK,eAAe;AAIpB,SAAK,cAAc;AACnB,QAAI,OAAO,KAAK,QAAQ,cAAc;AAClC,WAAK,QAAQ,aAAa;AAC9B,QAAI,OAAO,KAAK,QAAQ,qBAAqB;AACzC,WAAK,QAAQ,oBAAoB;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW,OAAO,GAAG;AACjB,QAAI,KAAK,QAAQ;AACb,UAAI,CAAC,KAAK,QAAQ;AACd,aAAK,OAAO;AAChB,UAAI,OAAO,GAAG;AACV,YAAI,WAAW,KAAK;AACpB,YAAI,OAAO,OAAO,KAAK,QAAQ;AAC/B,YAAI;AACA,qBAAW,SAAS,MAAM,GAAG,SAAS,SAAS,KAAK,CAAC,EAAE,MAAM;AACjE,iBAAS,IAAI,GAAG,IAAI,MAAM;AACtB,eAAK,OAAO,WAAW;AAAA,MAC/B;AACA,WAAK,SAAS;AAAA,IAClB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ,MAAM;AACV,QAAI,OAAO,KAAK,MAAM,IAAI;AAC1B,QAAI,CAAC,MAAM;AACP,UAAI,KAAK,QAAQ,WAAW;AACxB,cAAM,IAAI,MAAM,eAAe,IAAI,uCAAuC;AAC9E,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,UAAU,OAAO,YAAY,MAAM,GAAG;AAClC,QAAI,MAAM,KAAK;AACf,SAAK,MAAM,cAAc,OAAO,aAAa,KAAK;AAClD,SAAK,SAAS;AACd,MAAE;AACF,SAAK,QAAQ;AACb,SAAK,WAAW,IAAI;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAIA,UAAU;AACN,WAAO,UAAU,KAAK,KAAK,GAAG;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAIA,gBAAgB;AACZ,QAAI,CAAC,KAAK,QAAQ;AACd,WAAK,OAAO;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,SAAS;AACX,SAAK,WAAW;AAChB,QAAI,KAAK,SAAS,KAAK,QAAQ;AAC3B,WAAK,OAAO,KAAK;AACrB,QAAI;AACA,WAAK,OAAO;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW,MAAM;AACb,SAAK,SAAS;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,KAAK,MAAM,SAAS,MAAM;AACtB,QAAI,QAAQ,KAAK,MAAM,IAAI;AAC3B,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACnC,WAAK,MAAM;AAEX,UAAI,CAAC,UAAU,MAAM,CAAC,EAAE,CAAC,KAAK,OAAO,eAAe,KAAK,KAAK,GAAG;AAC7D,aAAK,MAAM,KAAK,IAAI,MAAM,GAAG,KAAK,IAAI,SAAS,CAAC,IAAI;AACxD,WAAK,OAAO,SAAS,KAAK,IAAI,MAAM,CAAC,GAAG,KAAK,YAAY,IAAI,MAAM,CAAC;AACpE,UAAI,KAAK,MAAM,SAAS;AACpB,aAAK,OAAO;AAAA,IACpB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO,MAAM,QAAQ,OAAO;AACxB,QAAI,KAAK,MAAM,KAAK,KAAK,IAAI,GAAG;AAC5B,WAAK,MAAM,KAAK,KAAK,IAAI,EAAE,MAAM,MAAM,QAAQ,KAAK;AAAA,IACxD,OACK;AACD,UAAI,KAAK,QAAQ,WAAW,OAAO;AAC/B,cAAM,IAAI,MAAM,iBAAiB,KAAK,KAAK,OAAO,sCAAsC;AAAA,MAC5F,WACS,CAAC,KAAK,KAAK,QAAQ;AACxB,YAAI,KAAK,KAAK;AACV,eAAK,aAAa,IAAI;AAAA;AAEtB,eAAK,cAAc,IAAI;AAC3B,YAAI,KAAK;AACL,eAAK,WAAW,IAAI;AAAA,MAC5B;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc,QAAQ;AAClB,WAAO,QAAQ,CAAC,MAAM,GAAG,MAAM,KAAK,OAAO,MAAM,QAAQ,CAAC,CAAC;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa,QAAQ,iBAAiB,MAAM;AACxC,SAAK,eAAe;AACpB,QAAI,SAAS,CAAC,GAAG,WAAW;AAC5B,QAAI,WAAW,CAAC,MAAM,QAAQ,UAAU;AACpC,UAAI,QAAQ,OAAO,KAAK,QAAQ,CAAC;AAIjC,UAAI,QAAQ,KAAK,KAAK,SAAS,KAAK,QAAQ;AACxC,gBAAQ,MAAM,OAAO,OAAK;AACtB,cAAI,QAAQ,KAAK,OAAO;AACpB,mBAAO;AACX,cAAI,OAAO,OAAO,MAAM,QAAQ,CAAC;AACjC,iBAAO,EAAE,QAAQ,KAAK,KAAK,MAAM,CAAC,KAAK,UAAU,KAAK,KAAK,KAAK,IAAI;AAAA,QACxE,CAAC;AACL,UAAI,UAAU;AACd,iBAAW;AAGX,UAAI,QAAQ,KAAK,UAAU,MAAM,KAAK,UAAQ;AAC1C,YAAI,OAAO,KAAK,QAAQ,KAAK,KAAK,IAAI;AACtC,eAAO,QAAQ,KAAK,4BAA4B,CAAC,KAAK,QAAQ,MAAM;AAAA,MACxE,CAAC,GAAG;AACA,YAAI,CAAC,GAAG,MAAM,IAAI,IAAI,eAAe,KAAK,KAAK,IAAI;AACnD,YAAI,MAAM;AACN,qBAAW;AACX,iBAAO,OAAO,KAAK,SAAS,IAAI,IAAI;AACpC,cAAI,CAAC;AACD,oBAAQ;AAAA,QAChB;AAAA,MACJ;AACA,UAAI,QAAQ,KAAK,UAAU,MAAM,KAAK,UAAQ;AAC1C,YAAI,OAAO,KAAK,QAAQ,KAAK,KAAK,IAAI;AACtC,eAAO,QAAQ,KAAK,6BACf,SAAS,OAAO,aAAa,KAAK,CAAC,KAAK,QAAQ,OAAO,MAAM,QAAQ,CAAC,EAAE,KAAK;AAAA,MACtF,CAAC,GAAG;AACA,YAAI,CAAC,GAAG,MAAM,KAAK,IAAI,gBAAgB,KAAK,KAAK,IAAI;AACrD,YAAI,OAAO;AACP,qBAAW;AACX,iBAAO,OAAO,KAAK,SAAS,IAAI,IAAI;AACpC,cAAI,CAAC;AACD,oBAAQ;AAAA,QAChB;AAAA,MACJ;AACA,UAAI,QAAQ,MAAM,SAAS,MAAM,MAAM,SAAS,CAAC,IAAI;AACrD,UAAI,QAAQ,SAAS,KAAK,QAAQ,MAAM,KAAK,IAAI,EAAE,WAAW;AAC9D,UAAI,MAAM,MAAM,UAAU,QAAQ,IAAI;AAKtC,YAAO,UAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AACjC,YAAI,OAAO,MAAM,CAAC;AAClB,YAAI,CAAC,KAAK,QAAQ,KAAK,KAAK,IAAI,EAAE;AAC9B;AACJ,iBAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACpC,cAAI,QAAQ,OAAO,CAAC;AACpB,cAAI,CAAC,KAAK,QAAQ,MAAM,KAAK,IAAI,EAAE;AAC/B;AACJ,cAAI,KAAK,GAAG,KAAK,GAAG;AAChB,gBAAI,IAAI;AACJ,sBAAQ,MAAM,MAAM,GAAG,CAAC,EAAE,OAAO,IAAI,EAAE,OAAO,MAAM,MAAM,GAAG,CAAC,CAAC,EAAE,OAAO,MAAM,MAAM,IAAI,GAAG,GAAG,CAAC;AAAA,qBAC1F,IAAI;AACT,sBAAQ,MAAM,MAAM,GAAG,CAAC,EAAE,OAAO,MAAM,MAAM,IAAI,GAAG,CAAC,CAAC,EAAE,OAAO,IAAI,EAAE,OAAO,MAAM,MAAM,GAAG,GAAG,CAAC;AACnG,qBAAS;AAAA,UACb;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,OAAO;AACX,aAAO,OAAO,KAAK,IAAI,OAAO,QAAQ,GAAG,KAAK,MAAM,IAAI,EAAE,GAAG,OAAO,IAAI,CAAC;AACrE,UAAE;AAEN,aAAO,OAAO,OAAO;AACjB,aAAK,KAAK,KAAK,WAAW,OAAO,IAAI,GAAG,OAAO,QAAQ,KAAK,GAAG,KAAK;AAExE,UAAI;AACA,aAAK,KAAK,OAAO;AAErB,UAAI,MAAM;AACN,eAAO,OAAO,SAAS,KAAK;AACxB,cAAI,MAAM,MAAM,OAAO,MAAM;AAC7B,iBAAO,KAAK,GAAG;AACf,eAAK,KAAK,KAAK,WAAW,KAAK,MAAM,QAAQ,KAAK,GAAG,KAAK;AAC1D,eAAK,eAAe;AAAA,QACxB;AAGA,YAAI,SAAS,KAAK;AACd,eAAK,KAAK,KAAK,WAAW,OAAO,MAAM,QAAQ,KAAK,IAAI,KAAK,OACzD,KAAK,WAAW,OAAO,OAAO,QAAQ,QAAQ,CAAC,GAAG,KAAK;AAAA;AAE3D,eAAK,OAAO,MAAM,QAAQ,KAAK;AACnC,aAAK,eAAe;AAAA,MACxB;AAOA,WAAK,SAAS,QAAQ,SAAS,SAAS,SAAS,KAAK,WAAW,KAAK,WAAW,GAAG;AAChF,aAAK,eAAe;AAAA,MACxB;AAAA,IACJ;AACA,WAAO,QAAQ,QAAQ;AACvB,aAAS,MAAM,GAAG,OAAO,UAAU;AACnC,SAAK,eAAe;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,MAAM,OAAO,YAAY;AAChC,QAAI,KAAK,UAAU,KAAK,OAAO,QAAQ,KAAK;AACxC,WAAK,WAAW,CAAC;AAAA,aACZ,KAAK;AACV,WAAK,WAAW,CAAC;AACrB,QAAI,UAAU,OAAO,KAAK,MAAM,SAAS,cAAc,KAAK,MAAM,QAAQ,KAAK,QAAQ;AACvF,QAAI,YAAY,KAAK;AACrB,SAAK,cAAc;AACnB,SAAK,QAAQ,CAAC,OAAO,GAAG,MAAM;AAC1B,UAAI,KAAK;AACL,aAAK,WAAW,CAAC;AACrB,WAAK,UAAU,OAAO,WAAW,CAAC,GAAG,MAAM,MAAM,KAAK,OAAO,OAAO,MAAM,CAAC,CAAC;AAAA,IAChF,CAAC;AACD,SAAK,cAAc;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,KAAK,cAAc,OAAO;AAC1B,UAAM,IAAI,QAAQ,iBAAiB,CAAC,GAAG,MAAM,KAAK,OAAO,IAAI,KAAK,IAAI,IAAI,IAAI,UAAU,IAAI,IAAI,CAAC,EAAE,MAAM,IAAI,KAAK,IAAI,IAAI,CAAC,EAAE,MAAM,IAAI,IAAI,IAAI,OAAO,CAAC;AACvJ,QAAI;AACA,YAAM,IAAI,QAAQ,mBAAmB,MAAM,EAAE,QAAQ,wBAAwB,UAAU,EAAE,QAAQ,iBAAiB,QAAQ;AAC9H,QAAI,KAAK,QAAQ;AACb,YAAM,IAAI,QAAQ,KAAK,QAAQ,uBAAuB,MAAM;AAChE,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,KAAK;AACP,QAAI,OAAO,IAAI,QAAQ,GAAG,KAAK,KAAK,OAAO,IAAI,QAAQ,GAAG,KAAK,KAAK,OAAO;AAC3E,WAAO,KAAK,CAAC,IAAI,MAAM,KAAK,CAAC;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAIA,OAAO,KAAK,GAAG;AACX,QAAI,MAAM;AACV,aAAS,IAAI,GAAG,IAAI,GAAG;AACnB,aAAO;AACX,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW,MAAM,MAAM,QAAQ,OAAO;AAClC,QAAI,OAAO,KAAK,QAAQ,KAAK,KAAK,IAAI;AACtC,QAAI,QAAQ,OAAO,KAAK,OAAO,KAAK;AACpC,WAAO,OAAO,SAAS,WAAW,QAAQ,MAAM,MAAM,MAAM,QAAQ,KAAK;AAAA,EAC7E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,uBAAuB,MAAM;AACzB,WAAO;AAAA,MACH,UAAU,KAAK,MAAM,QAAQ,KAAK,CAAC,MAAS,GAAG,CAAC;AAAA,MAChD,WAAW,KAAK,MAAM,QAAQ,KAAK,CAAC,MAAS,GAAG,CAAC;AAAA,IACrD;AAAA,EACJ;AACJ;",
  "names": ["schema", "tokenHandlers", "attrs", "tokens"]
}
